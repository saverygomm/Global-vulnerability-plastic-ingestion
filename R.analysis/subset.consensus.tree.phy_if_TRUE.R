# # Note, ConsensusTree.phy was downloaded in 2018 using
# # R version 3.4.1 (2017-06-30)
# # Platform: x86_64-apple-darwin15.6.0 (64-bit)
# # Running under: macOS Sierra 10.12.6


# Not necessary to re-download the phylogentic data from the online Tree of Life. The one downloaded in 2018 is sufficient ("./ConsensusTree.phy"). Also not necessary to re-extract the SEABIRD phylogentic data from the phylogenetic tree "./ConsensusTree.phy" every time. 
# The seabird subset is provided ("./output/ConsensusTree_seabird_matched.phy")")
# However, if you want to adjust the identification of seabird species in the phylogenetic tree, you can adjust here. 


## Script to produce "ConsensusTree_seabird_matched.phy"

# Prepare the seabird phylogenetic tree by subsetting seabird species out of ConsensusTree.phy based on their scientific names, or load:
resubset.consensus.tree.phy <- FALSE

if(resubset.consensus.tree.phy == TRUE){ 
# Load ConsensusTree.phy 
tree.complete <- read.tree("./output/ConsensusTree.phy")

# Check: Are all the species in seabird.list present as tip.labels in ConsensusTree.phy?

# Plastic data
TipLabel_BirdTree <- unique(data$TipLabel_BirdTree)
seabirds.of.interest <- (as.data.frame(TipLabel_BirdTree))
nrow(seabirds.of.interest) # 375
str(seabirds.of.interest)

# Tree of Life
ROTL.TipLabel <- unique(tree.complete$tip.label)
Matched <- rep("Y", length(tree.complete$tip.label))
tree.Matched <- as.data.frame(cbind(ROTL.TipLabel, Matched))

# All species of interest present in TOL? If so, left join should yield same number of species. 
test <- left_join(seabirds.of.interest, tree.Matched, by = c("TipLabel_BirdTree" = "ROTL.TipLabel"))
nrow(test) #375
paste("Are all the species in our seabird dataset in the Tree of Life dataset?", nrow(seabirds.of.interest) == nrow(test))
# View(test)
write.csv(test, paste0("./FYI/Seabird species of interest in ConsensusTree.phy_",Sys.Date(),".csv"), row.names = F)

# Tidy
rm(list = c('Matched','tree.Matched','test','TipLabel_BirdTree','data2','TipLabel_BirdTree_NA_positions','TipLabel_BirdTree_NAs'))

# ConsensusTree has >9999 species and only a subset are of interest in this study. Here, we remove tips for species that are not in data, calculate Grafen's arbitrary branch lengths, and plot

# Remove tips for non-relevant species (3 not recognized by BirdTree)

tree.seabird <-  drop.tip(tree.complete, tip = tree.complete$tip.label[!tree.complete$tip.label %in% seabirds.of.interest$TipLabel_BirdTree])
length(tree.seabird$tip.label) # 353

# If there are seabird species that are not in the ConsensusTree, figure out if we care then remove these levels from data
data.species.list <- levels(data$TipLabel_BirdTree)
data.species.list[!data.species.list %in% tree.seabird$tip.label]
species.to.remove.from.data <- as.factor(data.species.list[!data.species.list %in% tree.seabird$tip.label]) # None! Levels: 0

# Remove those species if any. 
data <- data %>% 
filter(TipLabel_BirdTree %notin% species.to.remove.from.data) 

data <- droplevels(data)

# Species missing from the tree
missing.from.ConsensusTree <- levels(data$TipLabel_BirdTree)
missing.from.ConsensusTree[!missing.from.ConsensusTree %in% tree.seabird$tip.label] # None! character(0)


# # Calculate Grafen's arbitrary branch lengths. We opted to use the branch lengths that were generated when the tree was extracted, so this is commented out.
# tree.brlen <- compute.brlen(tree.seabird, method = "Grafen") # What is this? There is no published justification for choosing one method of calculating branch length over another. When the tree is generated it has this computed branch lengths - which is Grafen's model. The height of each node is == to the number of decendents tips. Assuming that the branch length was reasonable the first time around you don't need to change it. But if you didn't have the full set of species the first time, you could do it again. This is two different ways of getting arbitrary branch lengths. We opted to use the branch lengths that were generated when the tree was extracted, so this is commented out. 

#Check that the trees are rooted. I.e., whether a phylogenetic tree is rooted with respect to the specified outgroup or at the node specified in "node".
is.rooted(tree.seabird)
is.rooted(tree.complete)

# Save (or resave)
write.tree(tree.seabird, paste0("./output/ConsensusTree_seabird_matched_",Sys.Date(),".phy"))
save.image(paste0("./RData.Session/R.3.5.3_(2019-03-11)_",Sys.Date(),".RData"))

# Tidy
rm(list = c('missing.from.ConsensusTree','species.to.remove.from.data'))
}

