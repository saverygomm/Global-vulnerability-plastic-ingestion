---
title: "Avery-Gomm et al. (TBD) Global seabird plastic ingestion vulnerability predicted using life history and phylogeny"
authors: "Stephanie Avery-Gomm, Craig White"
date: '2019-04-19'
---

Predictions of plastic ingestion across species

Now that we've identified factors that matter to the miniumum adequate model (Feeding.Method + Nocturnal.Foraging + Age.Class + Diet), the minimum adequate model was then re-run using MCMCglmm, so that the posterior estimates for the random effect of phylogeny could be calculated, such that phylogenetially informed species-level estimates could be constructed for species that were not present in the data (i.e., unstudied species). 

Input files
"./R.analysis/V7_CraigWhite/ConsensusTree.phy"

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
root.dir = dirname(getwd()) # this might work better for PC users.
knitr::opts_knit$set(root.dir = root.dir)
```


```{r initialize}

# Initialize
getwd()

# Initializing
# Clear workspace
rm(list=ls())
gc()

# Run this in     
    
    # R version 3.5.3 (2019-03-11)
    # Platform: x86_64-apple-darwin15.6.0 (64-bit)
    # Running under: macOS Sierra 10.12.6

# # First time? Load packages that are the same as the ones downloaded to run this project by using 'checkpoint' to load packages as of a specified date
install.packages("checkpoint")
library(checkpoint)
checkpoint::setSnapshot("2019-04-19")

# Not first time? Assume these all will load your sessionInfo() matches
    sessionInfo()
    # R version 3.5.3 (2019-03-11)
    # Platform: x86_64-apple-darwin15.6.0 (64-bit)
    # Running under: macOS Sierra 10.12.6
    # See README for full R 3.5.3 session details.
    
# Load Packages
library(caper)
library(car)
library(phylolm)
library(lmtest)
library(phytools) # used for 'read.tree'
library(boot)
library(lme4)
library(gtools)
library(ape)
library(MCMCglmm)
library(MuMIn)
# library(plyr)
library(tidyverse)
library(beepr)

options(scipen=999, digits = 3)

```

```{r setup_questions}
# Setup Options

# Load published versions where options exist?
use.published <- TRUE # FALSE here will load files created today by default, otherwise edits must be made to the 'read.csv' code each time. 

# For 'Priority' definition in prediction_Age Summary 
low.FO.is.less.than <- 0.60 
small.samples.have.less.than <-50

# Tidy Plastic data  (set to FALSE to load published results)
recreate.clean.MCMCglmm_dataMC <- FALSE

# Set to TRUE to run predictive model (~10-15 min run time). FALSE will load previously generated (published) predictions. Each run will be slightly different, as is the nature of this analysis. 
run.m1.6.MCMCglmm_Age <- FALSE
generate_predictions.summary <- TRUE

```

Here we subset the full dataset, to generage a dataset suitable for the MCMCglmm. Estimates were not possible for 10 species due to incomplete information on diet or foraging mode. Because Age.Class and Decade_Date are in the minimum adequate model, we set to Age.Class to "A" and Decade_Date to "2010s" to generate estimates for adults, currently. It was a strategic decision to use Decade_Date instead of Date_FirstYR bc the later has more levels, and the former encompasses all cases. Neither  changes the minimum adequate model. 
```{r prep_data_MCMCglmm}
 
print(paste0("if ", recreate.clean.MCMCglmm_dataMC, " == FALSE and ", use.published," == TRUE this chunk will load PUBLISHED version"))

if(recreate.clean.MCMCglmm_dataMC == TRUE){ 

    if(use.published == TRUE){
    dataMC <- read.csv("./output/study_lvl_plastic_data2_traits_clean_2019-03-18_PUBLISHED.csv")
    }else{
    # If don't want to use published version, load one created today or specify date of latest version (look up latest using list.files())
    list.files("./output/")
    dataMC <- read.csv(paste0("./output/study_lvl_plastic_data2_traits_clean_",Sys.Date(),".csv"))
    }

colnames(dataMC)
# View(dataMC)
levels(unique(dataMC$TipLabel_BirdTree)) # 351 species!

# Species fixed-factors that are used in the prediction cannot be NA
    
        # FEEDING METHOD
        # View(subset(data2, is.na(Feeding.Method)))
        f <- subset(dataMC, is.na(Feeding.Method))
        f$Common.name_BirdTree # None
        dataMC <- subset(dataMC, !is.na(Feeding.Method))
        nrow(dataMC) # 1658
    
        # DIET
        # View(subset(dataMC, Diet == "Unknown"))
        h <- subset(dataMC, Diet == "Unknown")
        h$Common.name_BirdTree  # Matsudaira's Storm-petrel Ringed Storm-petrel       Swinhoe's Storm-petrel    Fiji Petrel               Mascarene Petrel          Heinroth's Shearwater      
        dataMC <- subset(dataMC, Diet != "Unknown")
        nrow(dataMC) # 1652
        
        d <- subset(dataMC, is.na(Diet))
        d$Common.name_BirdTree # None
        dataMC <- subset(dataMC, !is.na(Diet))
        nrow(dataMC) # 1652
        
# Decade_Date and Age.Class are significant. To facilitate predictions, assign these factor levels to unstudied spe
        
        # DECADE_DATE
        # We cannot have blank Date_FirstYr, so must assign a year to this field for unstudied species. With Age, we assigned "Adult". For FirstYR we will assign 2010s. This way as a default our estimates will be for this decade.
        filter(dataMC, is.na(Date_Decade))
        levels(dataMC$Date_Decade)
        dataMC$Date_Decade <- as.character(dataMC$Date_Decade)
        dataMC <- mutate(dataMC, Date_Decade = ifelse(is.na(Date_Decade), "2010s", Date_Decade))
        filter(dataMC, is.na(Date_Decade))
        dataMC$Date_Decade <- as.factor(dataMC$Date_Decade)
        # str(dataMC)
        nrow(dataMC) #1652
        
        # ADULT
        # Add "A" to age for any species that haven't been studied so that there isn't an NA. Do the same for n if including that (we aren't here)
        filter(dataMC, is.na(Age.Class))
        dataMC <- dataMC %>%
        mutate(Age.Class = fct_explicit_na(Age.Class, na_level = "A"))
        filter(dataMC, is.na(Age.Class))
        nrow(dataMC) # 1652


dataMC_Age <- dataMC       
# Save this edited version of dataMC
write.csv(dataMC_Age, paste0("./output/study_lvl_plastic_data_traits_mcmcglmm_fixedfactorsNA_removed_Adult_2010s_",Sys.Date(),".csv"), row.names = F)
print(paste0("Created dataMC with FO with NA included, but unstudied species age class and decade set to Adult and 2010s respectively. MCMCglmm fixed factors is.na(Diet, Feeding.Method) has been removed = ", nrow(dataMC)," rows"))     

# "Created dataMC with FO with NA included, but unstudied species age class and decade set to Adult and 2010s respectively. MCMCglmm fixed factors is.na(Diet, Feeding.Method) has been removed = 1652 rows"
 } else { 

     
     if(use.published == TRUE){
        dataMC_Age <- read.csv(paste0("./output/study_lvl_plastic_data_traits_mcmcglmm_fixedfactorsNA_removed_Adult_2010s_2019-03-18_PUBLISHED.csv"))    
        
    print(paste0("Loaded *published* dataMC has 1652 = ", nrow(dataMC_Age)," rows. Here unstudied species with is.na(FO) are included and Age.Class and Decade.Date set to Adult and 2010s respectively. MCMCglmm fixed factors is.na(Diet, Feeding.Method) excluded"))    
    
        }else{
        # If don't want to use published version, load one created today or specify date of latest version (look up latest using list.files())
        list.files("./output/")
        dataMC_Age <- read.csv(paste0("./output/study_lvl_plastic_data_traits_mcmcglmm_fixedfactorsNA_removed_Adult_2010s_",Sys.Date(),".csv"))
        
        print(paste0("Loaded recently created dataMC has ", nrow(dataMC_Age)," rows (compared to published which had 1652). Here unstudied species with is.na(FO) are included and Age.Class and Decade.Date set to Adult and 2010s respectively. MCMCglmm fixed factors is.na(Diet, Feeding.Method) excluded"))    
        }
    
     }


```

```{r m1.6.MCMCglmm_Adult_2010s}

print(paste0("if ", run.m1.6.MCMCglmm_Age, " == FALSE this chunk will load PUBLISHED version"))

# req "./output/study_lvl_plastic_data_traits_mcmcglmm_fixedfactorsNA_removed_Adult_2010s_2019-03-18_PUBLISHED.csv"
# req "./output/ConsensusTree_seabird_matched.phy"


# Run even if run.m1.6.MCMCglmm_Age = FALSE
        
    # Rename data
    dim(dataMC_Age) # 1652 76 
        
    # For back transformations
    logit.delta <- min(min(dataMC_Age$FO[dataMC_Age$FO != 0], na.rm = T), 
                       max(dataMC_Age$FO[dataMC_Age$FO != 1], na.rm = T)) # [1] 0.0007 Same as above
    logit.delta == 0.0007
    
    # Dealing with Error:  row names of animal ginverse must be unique. This means there should be a match between the species in tree.seabird and dataMC$animal.
    length(levels(unique(dataMC_Age$TipLabel_BirdTree))) # 345
    length(levels(unique(dataMC_Age$animal))) # 345
    tree.seabird <- read.tree("./output/ConsensusTree_seabird_matched.phy")
    tree.seabird.345 <- drop.tip(tree.seabird, tip = tree.seabird$tip.label[!tree.seabird$tip.label %in% unique(dataMC_Age$TipLabel_BirdTree)])
    length(unique(tree.seabird.345$tip.label)) # 345
    
    # Confirm exact match between animal of each
    x <- as.data.frame(unique(dataMC_Age$animal))
    y <- as.data.frame(tree.seabird.345$tip.label)
    z <- full_join(x, y, by = c("unique(dataMC_Age$animal)" = "tree.seabird.345$tip.label"))
    # View(z)
    nrow(z) # 345
    rm(list = c('x','y','z'))
    
# # MGMGglmm will run or load it below. 
if(run.m1.6.MCMCglmm_Age == TRUE){

# Specify model parameters (used in publication, takes 5 min to run)
# iterations <- 1150000
# thinning   <- 1000
# burnin     <- 150000

# Quicky version
iterations <- 1150
thinning   <- 100
burnin     <- 150

#  Here we use *parameter expanded priors* for the random effects by including prior = prior1. Each (i.e., animal) random effect is represented by a G, and the residual is represented by R. The parameter expansion refers to the fact that we have included a prior mean (alpha.mu) and (co)variance matrix (alpha.V) as well as V and nu.
          prior1 <- list(G = list(G1 = list(V = diag(1), n = 0.002)),
                       R = list(V = diag(1), n = 0.002))
          # Make sure nodes are unique
          tree.seabird.345$node.label <- as.character(c(1:length(tree.seabird.345$node.label)))
          tree.seabird.345 <- ape::drop.tip(tree.seabird, tip = tree.seabird$tip.label[!tree.seabird$tip.label %in% unique(dataMC_Age$TipLabel_BirdTree)])
 
          
    # Run model with fixed factors that matter (based on asreml)
    m1.6.MCMCglmm_Age <- MCMCglmm(logit.F0 ~ Age.Class + Date_Decade + Feeding.Method + Diet,
             pedigree = tree.seabird.345,
             random = ~ animal,
             data = dataMC_Age, family = "gaussian",
             nitt = iterations, thin = thinning, burnin = burnin,
             prior = prior1,
             pr = TRUE, # To save the posterior mode of for each level or category in your random effect(s) we use pr = TRUE, which saves them in the $Sol part of the model output.
             verbose = TRUE)

        system("say Done done done done!")
        save(m1.6.MCMCglmm_Age, file = paste0("./output/MCMCglmm.products/m1.6.MCMCglmm_Adult_2010s_",Sys.Date(),".Rdata"))

    } else {
    
        if(use.published == TRUE){
        load(paste0("./output/MCMCglmm.products/m1.6.MCMCglmm_Adult_2010s_2019-03-18.PUBLISHED.Rdata"))
        print("Loaded *published* m1.6.MCMCglmm_Adult_2010s model")
        }else{
        # If don't want to use published version, load one created today or specify date of latest version (look up latest using list.files())
        list.files("./output/MCMCglmm.products/")
        load(paste0("./output/MCMCglmm.products/m1.6.MCMCglmm_Adult_2010s_",Sys.Date(),".Rdata"))
        print("Loaded *recently created* m1.6.MCMCglmm_Adult_2010s model")
            }
    
            }

```

```{r model_checks} 

# SUMMARY
    # The summary shows us a posterior mean for each effect, upper and lower 95% Credible Intervals (not Confidence Intervals) of the distribution, effective sample size and for the fixed effects, a pMCMC value.
     
    summary(m1.6.MCMCglmm_Age)

    #  Iterations = 150001:1149001
    #  Thinning interval  = 1000
    #  Sample size  = 1000 
    # 
    #  DIC: 8258 
    # 
    #  G-structure:  ~animal
    # 
    #        post.mean l-95% CI u-95% CI eff.samp
    # animal      77.1     42.7      115      876
    # 
    #  R-structure:  ~units
    # 
    #       post.mean l-95% CI u-95% CI eff.samp
    # units      15.3     14.1     16.6      904
    # 
    #  Location effects: logit.F0 ~ Age.Class + Date_Decade + Feeding.Method + Diet 
    # 
    #                                post.mean l-95% CI u-95% CI eff.samp  pMCMC    
    # (Intercept)                      -0.9945 -10.3024   8.6536      897  0.828    
    # Age.ClassMixed                   -1.0893  -1.7804  -0.4615     1000  0.006 ** 
    # Age.ClassNest-bound               2.4752   1.3650   3.7202     1000 <0.001 ***
    # Age.ClassSA                       0.6780  -0.1023   1.3272     1000  0.102    
    # Age.ClassSA_A                    -0.5487  -1.1815   0.2348      899  0.124    
    # Date_Decade1960s                  2.5297  -1.1986   6.7271     1000  0.196    
    # Date_Decade1970s                  2.9053  -0.6186   6.7086     1000  0.120    
    # Date_Decade1980s                  1.8152  -1.6768   5.5376     1000  0.350    
    # Date_Decade1990s                  3.0974  -0.5878   6.5331     1000  0.082 .  
    # Date_Decade2000s                  2.2641  -1.5308   5.7412     1000  0.230    
    # Date_Decade2010s                  1.1843  -2.5922   4.6839     1000  0.548    
    # Feeding.MethodBottom.Feeding     -3.8762  -9.4024   1.4266     1000  0.152    
    # Feeding.MethodDipping            -0.7528  -3.7457   2.2187     1000  0.652    
    # Feeding.MethodPattering          -1.9250  -6.4679   1.7627     1000  0.348    
    # Feeding.MethodPursuit.Diving     -3.3837  -7.1695   0.2523     1000  0.076 .  
    # Feeding.MethodPursuit.Plunging    2.2256  -1.0112   5.2298     1000  0.166    
    # Feeding.MethodScavenging         -2.6724  -6.6299   1.7759     1000  0.234    
    # Feeding.MethodSkimming            0.4996  -3.4342   4.5608     1138  0.782    
    # Feeding.MethodSurface.Plunging   -1.2284  -4.1404   2.0988      962  0.428    
    # Feeding.MethodSurface.Seizing     0.8205  -2.4906   3.3158      911  0.558    
    # DietCephalopods                  -4.6664  -8.1225  -1.4829     1000  0.004 ** 
    # DietCrustaceans                  -3.4491  -6.4270  -0.0504     1000  0.032 *  
    # DietFish                         -3.6077  -6.4941  -0.3854     1165  0.014 *  
    # DietOther.Inverts                -4.9956  -9.1661  -0.9506     1000  0.018 *  
    # ---
    # Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

# ASSESS SIGNIFICANCE
    
    # We can accept that a fixed effect is significant when the credible intervals do not span zero, this is because if the posterior distribution spans zero, we cannot be confident that it is not zero. While a pMCMC value is reported, it’s better to pay more attention to the credible intervals. Ideally your posterior distribution will also be narrow indicating that that parameter value is known precisely. 
    
    # With random effects, we estimate the variance. As variance cannot be zero or negative, we accept that a random effect is significant when the distribution of the variance is not pushed up against zero. To check this, we can plot the histogram of each posterior distribution. Plot the posterior distribution as a histogram to check for significance and whether it's been well estimated or not. Variance cannot be zero, and therefore if the mean value is pushed up against zero your random effect is not significant. The larger the spread of the histogram, the less well estimated the distribution is.
    par(mfrow = c(1,2))
    
    hist(mcmc(m1.6.MCMCglmm_Age$VCV)[,"animal"]) # Looks good
    hist(mcmc(m1.6.MCMCglmm_Age$VCV)[,"units"]) # Looks good
    
    par(mfrow=c(1,1)) # Reset the plot panel back to single plots
    
    
# ASSESSING MODEL CONVERGENCE
    # Now let’s check for model convergence. We do this separately for both fixed and random effects. Here you can see the trace and density estimate for the intercept. The trace is like a time series of what your model did while it was running and can be used to assess mixing (or convergence), while the density is like a smoothed histogram of the estimates of the posterior distribution that the model produced for every iteration of the model. 
        # To make sure your model has converged, the trace plot should look like a fuzzy caterpillar. It looks like the intercept has mixed well.
        # If you suspect too much autocorrelation there are a few things you can do: https://ourcodingclub.github.io/2018/01/22/mcmcglmm.html#syntax or for more on diagnostics: http://sbfnk.github.io/mfiidd/mcmc_diagnostics.html.
    
    # First, fixed effects
        # plot(m1.6.MCMCglmm_Age$Sol)
    
    # Second, random effects (there are many of these. key = esc to escape)
        # plot(m1.6.MCMCglmm_Age$VCV)
    
    
    # MODEL CHECKS   
    # Now, we COULD perform our model check by simulating new data given the same parameter values (variance/co-variance structures (priors)), and then plot it against our real data to make sure they overlap. Remember that in Bayesian analyses, the data remain fixed and it’s the parameters that change. So if we have used the correct parameters, we should be able to use them to simulate new data that look like the original. BUT WE WON'T. For more, go here https://ourcodingclub.github.io/2018/01/22/mcmcglmm.html#syntax
    
    # PREDICTIONS
    # In Bayesian statistics, the posterior predictive distribution is the distribution of possible unobserved values conditional on the observed values. 
    HPDinterval(m1.6.MCMCglmm_Age$Sol[,"(Intercept)"])
    
    # Examples of posterior modes and highest posterior density intervals for some Species in the tree, based on our prior knowledge - for which there is no plastic ingestion data
    posterior.mode(m1.6.MCMCglmm_Age$Sol[,"animal.Sterna_lorata"]) # This is on logit scale
    HPDinterval(m1.6.MCMCglmm_Age$Sol[,"animal.Sterna_lorata"]) # This is on logit scale
    mean(m1.6.MCMCglmm_Age$Sol[,"animal.Sterna_lorata"]) # This is on logit scale
    
    # And for some species in the data
    posterior.mode(m1.6.MCMCglmm_Age$Sol[,"animal.Puffinus_bulleri"]) # This is on logit scale
    HPDinterval(m1.6.MCMCglmm_Age$Sol[,"animal.Puffinus_bulleri"]) # This is on logit scale
    mean(m1.6.MCMCglmm_Age$Sol[,"animal.Puffinus_bulleri"]) # This is on logit scale
    
    
    # HPDinterval is particularly useful when you want to combine effects. Say you want to know the mean and the upper & lower 95% credible intervals of the posterior distribution of a particular species, based on what we know about it's life history. You can do that like this (see how combining important fixed factors improves the precision?)
    animal.of.interest <- "animal.Sterna_lorata"
    test.logit.FO <- m1.6.MCMCglmm_Age$Sol[,animal.of.interest]+
        m1.6.MCMCglmm_Age$Sol[,"Feeding.MethodSurface.Plunging"]+
        m1.6.MCMCglmm_Age$Sol[,"(Intercept)"]+
        m1.6.MCMCglmm_Age$Sol[,"Date_Decade2010s"]+
        m1.6.MCMCglmm_Age$Sol[,"DietFish"] +
        0 # for Age.Class = A, which is the baseline
    test.FO <- (logit.delta*exp(test.logit.FO)+logit.delta+exp(test.logit.FO))/(1+exp(test.logit.FO))
    HPDinterval(test.FO)
    mean(test.FO)
    
    
    animal.of.interest <- "animal.Puffinus_bulleri"
    test.logit.FO <- m1.6.MCMCglmm_Age$Sol[,animal.of.interest]+
        m1.6.MCMCglmm_Age$Sol[,"Feeding.MethodPursuit.Plunging"]+
        m1.6.MCMCglmm_Age$Sol[,"(Intercept)"]+
        mean(m1.6.MCMCglmm_Age$Sol[,"Date_Decade2010s"])+
        m1.6.MCMCglmm_Age$Sol[,"DietFish"] +
        0 # for Age.Class = A, which is the baseline
    test.FO <- (logit.delta*exp(test.logit.FO)+logit.delta+exp(test.logit.FO))/(1+exp(test.logit.FO))
    HPDinterval(test.FO)
    mean(test.FO)
    #     [1] 0.368
    
```

Generate predictions for each species in tree, using what we know about important species-level traits and the distributions from the MCMCglmm
```{r generate_predictions.summary}

print(paste0("if ", generate_predictions.summary, " == FALSE this chunk will load PUBLISHED version"))

if(generate_predictions.summary == TRUE){

    # Assume dataMC_Age already loaded.

    colnames(dataMC_Age)
    # dataMC_Age <- read.csv(paste0("./output/study_lvl_plastic_data_traits_mcmcglmm_fixedfactorsNA_removed_Adult_2010s_",Sys.Date(),".csv"))
    nrow(dataMC_Age) # Should have 1652 rows representing all the empirical data! 
    # View(dataMC_Age)
    
        # Create dataset that includes all the species traits factors from FULL model, and animal name - use for pulling out MCMCglmm results. # Diet, Feeding.Method, Date_Decade and Age.Class. 
        dataMC2_Age <- dataMC_Age %>%
            dplyr::select(Common.name_BirdTree, TipLabel_BirdTree, BLFamilyEnglish, Order, Feeding.Method, Date_Decade, Diet, Age.Class) %>%
            mutate(Age.Class = as.factor("A"),           # Have to make sure only one row per species, per age. 
                   Date_Decade = as.factor("2010s")) %>% # Have to make sure only one row per species, per decade. 
            distinct() %>%
            mutate(adjTipLabel_BirdTree = as.factor(paste0("animal.", TipLabel_BirdTree)), 
                   adjFeeding.Method = as.factor(paste0("Feeding.Method",Feeding.Method)),
                   adjDate_Decade = as.factor(paste0("Date_Decade", Date_Decade)),
                   adjDiet = as.factor(paste0("Diet",Diet)),
                   adjAge.Class = as.factor(paste0("Age.Class",Age.Class)))
    
    # Set up the empty dataframes for each summary result
    prediction_Age <- as.data.frame(NULL)
    prediction2_Age <- as.data.frame(NULL)
    
    # For each species for which we have trait data, which was run through the MCMCglmm, generate an estimate of FO that includes the minimum adequate model predictors.  # PINEAPPLE. This is important. Ask Craig to proof read? 
    
    for (i in 1:nrow(dataMC2_Age)){ 
        
        # If the fixed effect level == the baseline it is + 0. 
        test.logit.FO <-    
            # animal
            m1.6.MCMCglmm_Age$Sol[,dataMC2_Age[i,1]] + 
            # intercept
            m1.6.MCMCglmm_Age$Sol[,"(Intercept)"] +
            # Feeding.Method
            if(as.vector(dataMC2_Age$adjFeeding.Method[i]) %in% c("Feeding.MethodBottom.Feeding","Feeding.MethodDipping","Feeding.MethodPattering", "Feeding.MethodPursuit.Diving", "Feeding.MethodPursuit.Plunging", "Feeding.MethodScavenging", "Feeding.MethodSkimming","Feeding.MethodSurface.Plunging","Feeding.MethodSurface.Seizing"))  {m1.6.MCMCglmm_Age$Sol[,as.vector(dataMC2_Age$adjFeeding.Method[i])]} else{0} +
            # Diet
            if(as.vector(dataMC2_Age$adjDiet[i]) %in% c("DietCephalopods","DietCrustaceans","DietFish","DietOther.Inverts")) {m1.6.MCMCglmm_Age$Sol[,as.vector(dataMC2_Age$adjDiet[i])]} else{0} + 
            # Age.Class : we assigned level A
            if(as.vector(dataMC2_Age$adjAge.Class[i]) %in% c("Age.ClassSA_A", "Age.ClassSA", "Age.ClassMixed", "Age.ClassNest_bound")) {m1.6.MCMCglmm_Age$Sol[,as.vector(dataMC2_Age$adjAge.Class[i])]} else{0} +
            # Date_Decade : we assigned level: 2010s
        if(as.vector(dataMC2_Age$adjDate_Decade[i]) %in% c("Date_Decade1960s","Date_Decade1970s","Date_Decade1980s","Date_Decade1990s","Date_Decade2000s", "Date_Decade2010s")) {m1.6.MCMCglmm_Age$Sol[,as.vector(dataMC2_Age$adjDate_Decade[i])]} else{0}
        
        
        # Backtransform FO estimate   
        # For back transformations
        logit.delta <- min(min(dataMC_Age$FO[dataMC_Age$FO != 0], na.rm = T), 
                           max(dataMC_Age$FO[dataMC_Age$FO != 1], na.rm = T)) # [1] 0.0007 Same as above
        logit.delta == 0.0007
        test.FO <- (logit.delta*exp(test.logit.FO)+logit.delta+exp(test.logit.FO))/(1+exp(test.logit.FO))
        
        prediction_Age <- data.frame(TipLabel_BirdTree = as.vector(dataMC2_Age$TipLabel_BirdTree[i]),  
                                    lower.HPDinterval = round(HPDinterval(test.FO)[,1], digits = 3),  
                                    upper.HPDinterval = round(HPDinterval(test.FO)[,2], digits = 3),
                                    mean.FO =  round(mean(test.FO), digits = 3))
        
        prediction2_Age <- rbind(prediction2_Age, prediction_Age)
    }
    
    head(prediction2_Age)
    max(prediction2_Age$mean.FO) #   0.964
    # colnames(prediction2_Age) # "TipLabel_BirdTree" "lower.HPDinterval" "upper.HPDinterval" "mean.FO"    
    dim(prediction2_Age) # 345   4
    # View(prediction2_Age)
    

    
    
# Prepare Prediction Summary 
    
    # Remove variables with prefix "adj"
    prediction3_Age <- full_join(dataMC2_Age, prediction2_Age, by = "TipLabel_BirdTree")
    prediction3_Age <- prediction3_Age %>%
        select(-adjTipLabel_BirdTree,-adjFeeding.Method, -adjDiet, -adjDate_Decade, -adjAge.Class)
    
    # Figure out empirical FO sample size for each species, add to trait dataset (Note, this includes data for all Age.Classes and Decades!)
dataN_Age <- dataMC_Age %>%
    group_by(TipLabel_BirdTree) %>%
    summarise(minFO = round(min(FO, na.rm = TRUE), digits = 3),
              maxFO = round(max(FO, na.rm = TRUE), digits = 3),
              rangeFO = paste0(round(max(FO, na.rm = TRUE), digits = 3), " - ", round(min(FO, na.rm = TRUE), digits = 3)), 
              emp.meanFO = round(mean(FO, na.rm = TRUE), digits = 3), 
              emp.sdFO = round(sd(FO, na.rm = TRUE), digits = 3),
              sample.size = sum(n, na.rm = TRUE)) %>%
    mutate(sample.size = ifelse(is.na(sample.size), 0, sample.size)) %>%
    mutate(sampled = ifelse(sample.size == 0, "No", "Yes"))
    print("Expect warnings - this is bc we are calc mean, sd etc for some species that have NO empirical FO data. This is made tidy below.")

# str(dataMC_Age)
dim(dataN_Age) # 345   8
colnames(dataN_Age)

dataN_Age <- dataN_Age %>%
    mutate(minFO = ifelse(minFO == "Inf", NA, minFO),
           maxFO = ifelse(maxFO == "-Inf", NA, maxFO),
           rangeFO = ifelse(rangeFO == "-Inf - Inf", NA, rangeFO),
           emp.meanFO = ifelse(emp.meanFO == "NaN", NA, emp.meanFO))

    # View(dataN_Age)
    
    prediction.summary_Age <- left_join(prediction3_Age, dataN_Age, by = "TipLabel_BirdTree")
    prediction.summary_Age$TipLabel_BirdTree <- as.factor(prediction.summary_Age$TipLabel_BirdTree)
    
    
    # CHECK col names before reeordering
    head(prediction.summary_Age)
    str(prediction.summary_Age)
    dim(prediction.summary_Age) # Just 345 rows? Good
    colnames(prediction.summary_Age)
    prediction.summary_Age <- prediction.summary_Age %>%
        select(Common.name_BirdTree, TipLabel_BirdTree, BLFamilyEnglish, Order, Feeding.Method, Diet, Date_Decade, Age.Class, mean.FO, lower.HPDinterval, upper.HPDinterval, sampled, sample.size, minFO, maxFO, rangeFO, emp.meanFO, emp.sdFO)
    
    # View(prediction.summary_Age)
    
    # How precise is the estimate? Can we identify priority species?
    prediction.summary_Age <- prediction.summary_Age %>%
        mutate( interval = round(upper.HPDinterval - lower.HPDinterval, digits = 2), 
                HPDinterval_category = ifelse((upper.HPDinterval - lower.HPDinterval) < 0.5, "< 0.5", "> 0.5"))
    
    # # Which species have high predicted FO and low sample size? 
    # prediction.summary_Age <- prediction.summary_Age %>%
    #         mutate(small.sample = ifelse(sample.size < 100, "< 100", "> 100")) %>%
    #         mutate(small.sample = as.factor(small.sample)) %>%
    #         mutate(priority.highFO.lowN = ifelse(mean.FO >= 0.6 & sample.size < 100, "Yes", "No")) %>% 
    #         mutate(priority.highFO.lowN = as.factor(priority.highFO.lowN))
      
    
    # View(prediction.summary_Age)
    # table(prediction.summary_Age$HPDinterval_category)
    table(prediction.summary_Age$interval)
    
    colnames(prediction.summary_Age)
    
    prediction.summary_Age <- prediction.summary_Age %>%
        mutate(mean.FO = round(mean.FO, digits = 3),
               lower.HPDinterval = round(lower.HPDinterval, digits = 3),
               upper.HPDinterval = round(upper.HPDinterval, digits = 3))
    
    # View(prediction.summary_Age)
    
    # Add req variables  
    print(low.FO.is.less.than) # adjust at top of script
    print(small.samples.have.less.than) # adjust at top of script
    
    prediction.summary_Age <- prediction.summary_Age %>% 
        mutate(Order.title = str_to_title(Order)) %>%
        mutate(small.sample = ifelse(sample.size < small.samples.have.less.than, paste0("< ",small.samples.have.less.than), paste0("> ",small.samples.have.less.than))) %>%
        mutate(small.sample = as.factor(small.sample)) %>%
        mutate(priority.highFO.lowN = ifelse(mean.FO >= low.FO.is.less.than & sample.size < small.samples.have.less.than, "Yes", "No")) %>% 
        mutate(priority.highFO.lowN = as.factor(priority.highFO.lowN)) %>%
        mutate(Order = as.factor(str_to_title(Order))) 

table(prediction.summary_Age$priority.highFO.lowN)
#  No Yes 
# 266  79
table(prediction.summary_Age$small.sample)
# < 50 > 50 
#  239  106 
table(prediction.summary_Age$HPDinterval_category)
# < 0.5 > 0.5 
# 20   325 
table(prediction.summary_Age$Order.title)


# colnames(prediction.summary_Age)
# str(prediction.summary_Age)

    # Load species trait data so I can merge IUCN status in
    trait <- read.csv("./data/MASTER.keymassdietdmsstatus.traits_2018-12-17_PUBLISHED.csv")
    trait <- trait %>% 
        select(SISRecID_BLVr9, Common.name_BirdTree, X2016.IUCN.Red.List.category, Body.Mass.g, Nocturnal.Foraging, Opportunistic.Inferred, DMS.responsive_Dell.Ariccia, BLFamilyLatin) %>%
        # select(c(1, 3, 58, 15)) %>%
        distinct() # Sandwich Tern and Silver Gull have two rows bc there are two different SAUS names.
    # colnames(prediction.summary_Age)
    # colnames(trait)
    # dim(trait)
    
    test <- left_join(prediction.summary_Age, trait, by = "Common.name_BirdTree")
    colnames(test)
    
    nrow(prediction.summary_Age) == nrow(test) # If there is only one IUCN status for each species then this should = TRUE
    test2 <- dplyr::select(test, SISRecID_BLVr9, Common.name_BirdTree, TipLabel_BirdTree, BLFamilyEnglish, BLFamilyLatin, Order, Date_Decade, Age.Class, Diet, Feeding.Method, mean.FO, lower.HPDinterval, upper.HPDinterval, interval, HPDinterval_category, sampled,sample.size,emp.meanFO, emp.sdFO, minFO, maxFO, rangeFO, everything())
    colnames(test2)
    # View(test2)
    prediction.summary_Age <- test2
    # View(prediction.summary_Age)
        
    # SAVE 
    write.csv(prediction.summary_Age, file =     paste0("./output/MCMCglmm.products/m1.6.MCMCglmm_Adult_2010s.FO.predictions.345.species_",Sys.Date(),".csv"), row.names = FALSE)
    
}else{
    
        if(use.published == TRUE){
        prediction.summary_Age<- read.csv("./output/MCMCglmm.products/m1.6.MCMCglmm_Adult_2010s.FO.predictions.345.species_2019-03-25_PUBLISHED.csv")
        }else{
        # If don't want to use published version, load one created today or specify date of latest version (look up latest using list.files())
        list.files("./output/MCMCglmm.products/")
        prediction.summary_Age<- read.csv(paste0("./output/MCMCglmm.products/m1.6.MCMCglmm_Adult_2010s.FO.predictions.345.species_",Sys.Date(),".csv"))
            }
    
}

par(mfrow = c(2,1))
    
# How are predicted FO's distributed in a frequency histogram? 
hist(prediction.summary_Age$mean, main = "Mean predicted FO estimates \nwhen Age.Class = A, Date_Decade = 2010s is included \nw/ signficant factors: Diet, Feeding.Methode")            # If bimodal etc there are a few groups that are particularly vulnerable. 

# How is interval of FO estimates distributed in a frequency histogram? 
hist(prediction.summary_Age$interval, main = "HPD Interval of MCMCglmm FO estimates \nwhen Age.Class = A, Date_Decade = 2010s is included \nw/ signficant factors: Diet, Feeding.Method.")            # >150 species have large intervals (1)

par(mfrow=c(1,1)) # Reset the plot panel back to single plots


```

Now, on to graphics
Open 5 "Plot_and_report.Rmd"
